//// Created by thijs on 16/12/2022.//#include <fstream>#include <chrono>#include <vector>#include <stdexcept>#include <json/json.h>#include <iomanip>#include <numeric>#include "selfaveragespheredistance.hpp"SelfAverageSphereDistance::~SelfAverageSphereDistance() = default;SelfAverageSphereDistance::SelfAverageSphereDistance(Universe *myUniverse) : Observer(myUniverse) {}void SelfAverageSphereDistance::measurement() {    const Vertex *center = myUniverse->getRandomVertex();    SphereGrower sphere(center, myUniverse);    sphere.growToRadius(minRadius_);    std::vector<double> distances;    distances.reserve(sphere.getCircumference());    for (const Vertex *vertexOnShell : sphere.currentLayer_) {        DistanceMeasurer distancer(vertexOnShell, myUniverse, sphere);        distancer.setUnwanted(vertexOnShell);        // by triangle inequality, this is the maximum radius at which vertices of sphere can be found        unsigned int maxSize = 2*sphere.getRadius();        double averageDistance = distancer.measureAverageDistance(maxSize);        distances.push_back(averageDistance);    }    writeVector(distances);}void SelfAverageSphereDistance::writeVector(const std::vector<int> &data) {    std::ofstream outFile(fileName_, std::ofstream::app);    if(!outFile.is_open()) {        throw std::runtime_error("in `writeVector` of SelfAverageSphereDistance: Problem with opening file");    }    for (int datum : data) {        outFile << datum << ", ";    }    outFile << "\n";    outFile.close();}void SelfAverageSphereDistance::writeVector(const std::vector<unsigned int> &data) {    std::ofstream outFile(fileName_, std::ofstream::app);    if(!outFile.is_open()) {        throw std::runtime_error("in `writeVector` of SelfAverageSphereDistance: Problem with opening file");    }    for (unsigned int datum : data) {        outFile << datum << ", ";    }    outFile << "\n";    outFile.close();}void SelfAverageSphereDistance::setFileName(const std::string &addition) {    auto now = std::chrono::system_clock::now();    auto in_time_t = std::chrono::system_clock::to_time_t(now);    std::stringstream datetime;    datetime << std::put_time(std::localtime(&in_time_t), "%Y-%m-%d_%H-%M-%S");    std::string filename = baseName_ + addition + "_" + datetime.str() + ".txt";    fileName_ = filename;}std::string SelfAverageSphereDistance::getFileName() {    return fileName_;}void SelfAverageSphereDistance::loadSettingsFromConfig(const std::string &configLoc) {    Json::Value root;    std::ifstream ifs;    ifs.open(configLoc);    Json::CharReaderBuilder builder;    builder["collectComments"] = false;    Json::String errs;    if (!parseFromStream(builder, ifs, &root, &errs)) {        std::cout << errs << std::endl;        throw std::runtime_error("In `loadSettingsFromConfig` of SelfAverageSphereDistance: problem parsing config");    }    if (!root.isMember("observables")) {        throw std::runtime_error("In `loadSettingsFromConfig` of SelfAverageSphereDistance: no observable settings in config");    }    Json::Value observableRoot = root["observables"];    if (!observableRoot.isMember("self_average_sphere_distance")) {        throw std::runtime_error("In `loadSettingsFromConfig` of SelfAverageSphereDistance: no ASD settings in config");    }    Json::Value asdRoot = observableRoot["self_average_sphere_distance"];    if (asdRoot.isMember("min_radius")) {        minRadius_ = asdRoot["min_radius"].asUInt();    }    if (asdRoot.isMember("max_radius")) {        maxRadius_ = asdRoot["max_radius"].asUInt();    }}void SelfAverageSphereDistance::writeVector(const std::vector<double> &data) const {    std::ofstream outFile(fileName_, std::ofstream::app);    if(!outFile.is_open()) {        throw std::runtime_error("in `writeVector` of SelfAverageSphereDistance: Problem with opening file");    }    for (double datum : data) {        outFile << datum << ", ";    }    outFile << "\n";    outFile.close();}