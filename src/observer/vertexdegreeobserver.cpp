//// Created by thijs on 05/10/2022.//#include <vector>#include <stdexcept>#include <fstream>#include <chrono>#include <iomanip>#include <json/json.h>#include "vertexdegreeobserver.hpp"#include "src/jsonutilities/jsonutilities.hpp"#include "src/misc/histogram.hpp"VertexDegreeObserver::~VertexDegreeObserver() {}VertexDegreeObserver::VertexDegreeObserver(Universe *myUniverse) : Observer(myUniverse) {}void VertexDegreeObserver::measurement() {    auto numberOfVertices = myUniverse->numberOfVertices();    std::vector<int> degrees;    degrees.reserve(numberOfVertices);    for (int i = 0; i < numberOfVertices; ++i) {        auto vertex = myUniverse->getVertex(VertexLabel(i));        degrees.push_back(static_cast<int>(vertex->getDegree()));    }    Histogram myHist(degrees);    makeOutputFile();    writeHistogram(myHist.get_bins(), myHist.get_counts());}void VertexDegreeObserver::writeVector(const std::vector<int> &data) {    std::ofstream outFile(m_fileName, std::ofstream::app);    if(!outFile.is_open()) {        throw std::runtime_error("in `writeVector` of VertexDegreeObserver: Problem with opening file");    }    for (int datum : data) {        outFile << datum << ", ";    }    outFile << "\n";    outFile.close();}void VertexDegreeObserver::setFileName(const std::string &addition) {    auto now = std::chrono::system_clock::now();    auto in_time_t = std::chrono::system_clock::to_time_t(now);    std::stringstream datetime;    datetime << std::put_time(std::localtime(&in_time_t), "%Y-%m-%d_%H-%M-%S");    std::string filename = m_baseName + addition + "_" + datetime.str() + ".json";    m_fileName = filename;}std::string VertexDegreeObserver::getFileName() {    return m_fileName;}void VertexDegreeObserver::loadSettingsFromConfig(const std::string &configLoc) {    // intentionally left empty}void VertexDegreeObserver::writeHistogram(const std::vector<int>& bins, const std::vector<int>& counts) const {    Json::Value root;    std::fstream fs;    fs.open(m_fileName);    Json::CharReaderBuilder builder;    builder["collectComments"] = false;    Json::String errs;    if (!parseFromStream(builder, fs, &root, &errs)) {        std::cout << errs << std::endl;        throw std::runtime_error("In `writeHistogram` of VertexDegreeObserver: problem parsing config");    }    fs.close();    Json::Value measurement;    // convert vector to json arrays and add to measurement json value    measurement["bins"] = jsonUtilities::iterable2json(bins);    measurement["counts"] = jsonUtilities::iterable2json(counts);    root["measurements"].append(measurement);    fs.open(m_fileName, std::ios::out);    fs << root.toStyledString() << std::endl;    fs.close();}void VertexDegreeObserver::makeOutputFile() {    // make json file    Json::StreamWriterBuilder builder;    const std::unique_ptr<Json::StreamWriter> writer(builder.newStreamWriter());    Json::Value root;    root["measurements"] = Json::arrayValue;    std::ofstream outFile(m_fileName, std::ofstream::app);    if(!outFile.is_open()) {        throw std::runtime_error("in `makeOutputFile` of VertexDegreeObserver: Problem with opening file");    }    writer->write(root, &outFile);    outFile.close();}