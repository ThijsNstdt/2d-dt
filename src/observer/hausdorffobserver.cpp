//// Created by thijs on 15/12/2022.//#include <fstream>#include <chrono>#include <vector>#include <stdexcept>#include <json/json.h>#include <iomanip>#include <numeric>#include "hausdorffobserver.hpp"HausdorffObserver::~HausdorffObserver() = default;HausdorffObserver::HausdorffObserver(Universe *myUniverse) : Observer(myUniverse) {}void HausdorffObserver::measurement() {    const Vertex *startingVertex = myUniverse->getRandomVertex();    SphereGrower sphereGrower(startingVertex, myUniverse);    sphereGrower.growToEmptyShell();    const std::vector<unsigned int> volumeProfile = sphereGrower.shellSizes_;    if (std::reduce(volumeProfile.begin(), volumeProfile.end()) < myUniverse->numberOfVertices() ) {        throw std::runtime_error("universe is not one connected component");    }    writeVector(volumeProfile);}void HausdorffObserver::writeVector(const std::vector<int> &data) {    std::ofstream outFile(fileName_, std::ofstream::app);    if(!outFile.is_open()) {        throw std::runtime_error("in `writeVector` of HausdorffObserver: Problem with opening file");    }    for (int datum : data) {        outFile << datum << ", ";    }    outFile << "\n";    outFile.close();}void HausdorffObserver::setFileName(const std::string &addition) {    auto now = std::chrono::system_clock::now();    auto in_time_t = std::chrono::system_clock::to_time_t(now);    std::stringstream datetime;    datetime << std::put_time(std::localtime(&in_time_t), "%Y-%m-%d_%H-%M-%S");    std::string filename = baseName_ + addition + "_" + datetime.str() + ".txt";    fileName_ = filename;}std::string HausdorffObserver::getFileName() {    return fileName_;}void HausdorffObserver::loadSettingsFromConfig(const std::string &configLoc) {    Json::Value root;    std::ifstream ifs;    ifs.open(configLoc);    Json::CharReaderBuilder builder;    builder["collectComments"] = false;    Json::String errs;    if (!parseFromStream(builder, ifs, &root, &errs)) {        std::cout << errs << std::endl;        throw std::runtime_error("In `loadSettingsFromConfig` of HausdorffObserver: problem parsing config");    }    if (!root.isMember("observables")) {        throw std::runtime_error("In `loadSettingsFromConfig` of HausdorffObserver: no observable settings in config");    }    Json::Value observableRoot = root["observables"];    if (!observableRoot.isMember("hausdorff_dimension")) {        throw std::runtime_error("In `loadSettingsFromConfig` of HausdorffObserver:"                                 " no HausdorffObserver settings in config");    }    Json::Value hoRoot = observableRoot["hausdorff_dimension"];    if (hoRoot.isMember("max_radius")) {        maxRadius_ = hoRoot["max_radius"].asUInt();    }}void HausdorffObserver::writeVector(const std::vector<unsigned int> &data) {    std::ofstream outFile(fileName_, std::ofstream::app);    if(!outFile.is_open()) {        throw std::runtime_error("in `writeVector` of HausdorffObserver: Problem with opening file");    }    for (unsigned int datum : data) {        outFile << datum << ", ";    }    outFile << "\n";    outFile.close();}