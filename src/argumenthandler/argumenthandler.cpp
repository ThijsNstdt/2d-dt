//// Created by thijs on 13/01/2023.//#include "argumenthandler.hpp"#include <type_traits>#include <exception>#include <iostream>#include <cstring>#include <json/json.h>#include <fstream>#include <iomanip>#include <chrono>ArgumentHandler::ArgumentHandler(const int &argc) : argc_(argc) {    makeSimulationConfigName();}std::string ArgumentHandler::getSimulationConfig(char *argv[]) {    if (argc_ == 1) {        // no arguments given: default behaviour        return noArgumentHandling();    } else if (argc_ == 2) {        // config location specified:        return oneArgumentHandling(argv);    } else if (argc_ == 4) {        // repeats specified:        return threeArgumentHandling(argv);    } else if (argc_ == 5) {        return fourArgumentHandling(argv);    } else {        // stop program in case of unsupported number of arguments        std::cout << "This program requires either 0, 1, 3 or 4 arguments!" << std::endl;        std::cin.get();        throw std::runtime_error( "unsupported number of cmd line arguments: " + std::to_string(argc_-1) );    }}std::string ArgumentHandler::getPath(const std::string &file) {    std::size_t found = file.find_last_of('/');    return file.substr(0, found) + "/";}std::string ArgumentHandler::fourArgumentHandling(char **argv) {    // define basicConfigFile and its path    std::string baseConfigFile = argv[1];    std::string pathToBaseConfig = getPath(baseConfigFile);    // convert string arguments to std string    std::string firstStringArgument(argv[2]);    std::string secondStringArgument(argv[3]);    // convert third argument to int    int index;    std::string arg = argv[4];    try {        std::size_t pos;        index = std::stoi(arg, &pos);        if (pos < arg.size()) {            std::cerr << "Trailing characters after number: " << arg << " . Passed along as: " << index << '\n';        }    } catch (std::invalid_argument const &ex) {        std::cerr << "Invalid number: " << arg << '\n';    } catch (std::out_of_range const &ex) {        std::cerr << "Number out of range: " << arg << '\n';    }    addIndexToConfigName(index);    // read base config file    Json::Value root;    std::ifstream ifs;    ifs.open(baseConfigFile);    Json::CharReaderBuilder builder;    builder["collectComments"] = false;    Json::String errs;    if (!parseFromStream(builder, ifs, &root, &errs)) {        std::cout << errs << std::endl;        throw std::runtime_error("could not parse baseConfigFile");    }    ifs.close();    // check whether arguments lead the way to array in base config file    if (!root.isMember(firstStringArgument)) {        throw std::runtime_error("first program argument not in config file");    }    if (!root[firstStringArgument].isMember(secondStringArgument)) {        throw std::runtime_error("second program argument not under first argument in config file");    }    if (!root[firstStringArgument][secondStringArgument].isArray()) {        throw std::runtime_error("config file not suitable argument indexing of settings: not array value");    }    // check whether index argument actually properly indexes the array    if ( index >= root[firstStringArgument][secondStringArgument].size() && index < 0 ) {        throw std::runtime_error("index not in range for settings array");    }    // read out indexed value of array    auto newValue = root[firstStringArgument][secondStringArgument][index];    // replace the setting array with the chosen setting    root[firstStringArgument][secondStringArgument] = newValue;    root["array_job_info"]["index"] = index;    // write this altered json tree to new config file    std::ofstream ofs(simulationConfig_, std::ofstream::trunc);    if (!ofs.is_open()) {        throw std::runtime_error("can not open new configFile");    }    ofs << root.toStyledString() << std::endl;    ofs.close();    std::cout << "Made configFile " + simulationConfig_ + " for index " + std::to_string(index) << "\n";    // return generated config file name in order to read it out further down the line    return simulationConfig_;}void ArgumentHandler::makeSimulationConfigName() {    auto now = std::chrono::system_clock::now();    auto in_time_t = std::chrono::system_clock::to_time_t(now);    std::stringstream datetime;    datetime << std::put_time(std::localtime(&in_time_t), "%Y-%m-%d_%H-%M-%S");    simulationConfig_ = "./simulations/summary/simulation_" + datetime.str() + ".json";}std::string ArgumentHandler::noArgumentHandling() const{    // read base config file    Json::Value root;    std::ifstream ifs;    ifs.open("./config/config.json");    Json::CharReaderBuilder builder;    builder["collectComments"] = false;    Json::String errs;    if (!parseFromStream(builder, ifs, &root, &errs)) {        std::cout << errs << std::endl;        throw std::runtime_error("could not parse baseConfigFile");    }    ifs.close();    // write unaltered json tree to new config file    std::ofstream ofs(simulationConfig_, std::ofstream::trunc);    if (!ofs.is_open()) {        throw std::runtime_error("can not open new configFile");    }    ofs << root.toStyledString() << std::endl;    ofs.close();    // return generated config file name in order to read it out further down the line    return simulationConfig_;}std::string ArgumentHandler::oneArgumentHandling(char *argv[]) const {    std::string baseConfigFile = argv[1];    // read base config file    Json::Value root;    std::ifstream ifs;    ifs.open(baseConfigFile);    Json::CharReaderBuilder builder;    builder["collectComments"] = false;    Json::String errs;    if (!parseFromStream(builder, ifs, &root, &errs)) {        std::cout << errs << std::endl;        throw std::runtime_error("could not parse baseConfigFile");    }    ifs.close();    // write unaltered json tree to new config file    std::ofstream ofs(simulationConfig_, std::ofstream::trunc);    if (!ofs.is_open()) {        throw std::runtime_error("can not open new configFile");    }    ofs << root.toStyledString() << std::endl;    ofs.close();    // return generated config file name in order to read it out further down the line    return simulationConfig_;}void ArgumentHandler::addIndexToConfigName(const int &index) {    std::string copyOfConfig = simulationConfig_;    std::size_t found = copyOfConfig.find_last_of('.');    copyOfConfig = copyOfConfig.substr(0, found) + "_" + std::to_string(index) + ".json";    simulationConfig_ = copyOfConfig;}std::string ArgumentHandler::threeArgumentHandling(char **argv) {    // define basicConfigFile and its path    std::string baseConfigFile = argv[1];    std::string pathToBaseConfig = getPath(baseConfigFile);    // convert string arguments to std string    std::string firstStringArgument(argv[2]);    // convert second argument to int    int index;    std::string arg = argv[3];    try {        std::size_t pos;        index = std::stoi(arg, &pos);        if (pos < arg.size()) {            std::cerr << "Trailing characters after number: " << arg << " . Passed along as: " << index << '\n';        }    } catch (std::invalid_argument const &ex) {        std::cerr << "Invalid number: " << arg << '\n';    } catch (std::out_of_range const &ex) {        std::cerr << "Number out of range: " << arg << '\n';    }    addIndexToConfigName(index);    // read base config file    Json::Value root;    std::ifstream ifs;    ifs.open(baseConfigFile);    Json::CharReaderBuilder builder;    builder["collectComments"] = false;    Json::String errs;    if (!parseFromStream(builder, ifs, &root, &errs)) {        std::cout << errs << std::endl;        throw std::runtime_error("could not parse baseConfigFile");    }    ifs.close();    // check whether repeating is intentional    if (firstStringArgument != "repeat") {        throw std::runtime_error("this number of arguments is only compatible with repeats");    }    root["array_job_info"]["index"] = index;    // write this altered json tree to new config file    std::ofstream ofs(simulationConfig_, std::ofstream::trunc);    if (!ofs.is_open()) {        throw std::runtime_error("can not open new configFile");    }    ofs << root.toStyledString() << std::endl;    ofs.close();    std::cout << "Made configFile " + simulationConfig_ + " for index " + std::to_string(index) << "\n";    // return generated config file name in order to read it out further down the line    return simulationConfig_;}