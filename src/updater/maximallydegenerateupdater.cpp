//// Created by thijs on 05/10/2022.//#include "maximallydegenerateupdater.hpp"#include "src/observer/dualhausdorffobserver.hpp"#include <unistd.h>MaximallyDegenerateUpdater::~MaximallyDegenerateUpdater() = default;MaximallyDegenerateUpdater::MaximallyDegenerateUpdater(Universe *myUniverse) : Updater(myUniverse) {}void MaximallyDegenerateUpdater::edgeUpdate() {    clearIdentification();    addUpdate(); //rejection is also an update    // minimal identification to be able to distinguish cases    minimalIdentification();    updateType = "normal RD";    if (isInnerTadpoleEdgeFlip()) {        innerEdgeFlip();        updateType = "inner edge flip";        return;    }    if (zEdge->isOneNeck()) {        if (moveRemovesTadpole()) {            untadpoleIdentification();            untadpoleFlip();            aTriangle->toggleTadpole();            updateType = "tadpole removal";            return;        } else {            // here z is a one-neck, and the 5 identified edges are unique.            finishOneNeckIdentification();            regularFlip();            updateType = "one-neck not simple tadpole ";            return;        }    }    finishIdentificiation();    if (cVertex->getLabel() == dVertex->getLabel()) {        if (moveCreatesTadpole()) {            // take into account changing neighborhood in case of flip inside self energy            if (cTriangle->getLabel() == bTriangle->getLabel()) {                aTriangle->replaceNeighborByEdge(aTriangle, yEdge->getLabel());                aTriangle->toggleTadpole();            } else if (fTriangle->getLabel() == aTriangle->getLabel()) {                bTriangle->replaceNeighborByEdge(bTriangle, wEdge->getLabel());                bTriangle->toggleTadpole();            }            regularFlip();            updateType = "tadpole creation";            return;        }        // move creates a one-neck without a simple tadpole. The only difference with an RD flip is that z becomes        // a one-neck. However, that status update is already included in the setVertices method of Edge. The code        // below is therefore sufficient, and we can do nothing here.        updateType = "one-neck no tadpole creation";        // Intentionally left empty    }    if (isInnerTubeEdge()) {        updateType = "inner tube edge flip";        return;    }    regularFlip();}void MaximallyDegenerateUpdater::minimalIdentification() {    // identify central triangles and edge    aTriangle = myUniverse->getRandomTriangle();    auto myEdgeTriangleTuple = aTriangle->getRandomEdgeNeighborPair();    zEdge = std::get<0>(myEdgeTriangleTuple);    bTriangle = std::get<1>(myEdgeTriangleTuple);    // identify central vertices    auto myVerticesTuple = zEdge->getVertices();    aVertex = std::get<0>(myVerticesTuple);    bVertex = std::get<1>(myVerticesTuple);}bool MaximallyDegenerateUpdater::moveCreatesTadpole() {    if (aTriangle->hasNeighborTwice(bTriangle->getLabel())) {        return true;    }    return false;}bool MaximallyDegenerateUpdater::moveRemovesTadpole() {    // if neither are tadpoles, no tadpole can be removed. TODO: this can likely be removed, see its usage in if statement above    if ( !aTriangle->isTadpole() && !bTriangle->isTadpole() ) {        return false;    }    return true;}bool MaximallyDegenerateUpdater::isInnerTadpoleEdgeFlip() {    // no need to check for b, since if a is self neighbor through z, then b = a.    if ( aTriangle->isSelfNeighborThroughEdge(zEdge->getLabel()) ) {        return true;    }    return false;}void MaximallyDegenerateUpdater::innerEdgeFlip() {    // intentionally left empty}void MaximallyDegenerateUpdater::untadpoleIdentification() {    // swap triangle names such that a is always tadpole, will be equivalent up to relabeling.    if (bTriangle->isTadpole()) {        std::swap(aTriangle, bTriangle);    }    // get bVertex from zEdge, which contains it twice.    auto bVertexTuple = zEdge->getVertices();    bVertex = std::get<0>(bVertexTuple);    cVertex = bTriangle->vertexOppositeTo(zEdge->getLabel());    aVertex = aTriangle->vertexOppositeTo(zEdge->getLabel());    xEdge = aTriangle->edgeOppositeTo(bVertex->getLabel());    auto degenerateEdges = bTriangle->getDegenerateEdgesExcluding(zEdge);    vEdge = std::get<0>(degenerateEdges);    wEdge = std::get<1>(degenerateEdges);    cTriangle = bTriangle->neighborFromEdge(vEdge->getLabel());    dTriangle = bTriangle->neighborFromEdge(wEdge->getLabel());}void MaximallyDegenerateUpdater::untadpoleFlip() {    aTriangle->replaceTripletByEdge(aVertex, wEdge, dTriangle, xEdge->getLabel());    aTriangle->replaceTripletByEdge(cVertex, xEdge, bTriangle, xEdge->getLabel());    aTriangle->replaceVertexByEdge(bVertex, zEdge->getLabel());    bTriangle->replaceTripletByEdge(cVertex, xEdge, aTriangle, wEdge->getLabel());    bTriangle->replaceVertexByEdge(bVertex, zEdge->getLabel());    bTriangle->replaceVertexByEdge(aVertex, vEdge->getLabel());    dTriangle->replaceNeighborByEdge(aTriangle, wEdge->getLabel());    zEdge->setVertices(aVertex, cVertex);    bVertex->removeNeighbor(bVertex, zEdge->getLabel());    aVertex->addNeighbor(cVertex, zEdge->getLabel());    cVertex->addNeighbor(aVertex, zEdge->getLabel());}void MaximallyDegenerateUpdater::finishIdentificiation() {    // continue from minimal identification    // identify other important vertices    cVertex = aTriangle->vertexOppositeTo(zEdge->getLabel());    dVertex = bTriangle->vertexOppositeTo(zEdge->getLabel());    // identify the other important edges, if statements are needed in case v,w,x,y are 1-loops.    if (cVertex->getLabel() == bVertex->getLabel()) {        yEdge = aTriangle->otherEdgeContaining(aVertex->getLabel(), zEdge->getLabel());    } else {        yEdge = aTriangle->edgeOppositeTo(bVertex->getLabel());    }    if (cVertex->getLabel() == aVertex->getLabel()) {        xEdge = aTriangle->otherEdgeContaining(bVertex->getLabel(), zEdge->getLabel());    } else {        xEdge = aTriangle->edgeOppositeTo(aVertex->getLabel());    }    if (dVertex->getLabel() == bVertex->getLabel()) {        vEdge = bTriangle->otherEdgeContaining(aVertex->getLabel(), zEdge->getLabel());    } else {        vEdge = bTriangle->edgeOppositeTo(bVertex->getLabel());    }    if (dVertex->getLabel() == aVertex->getLabel()) {        wEdge = bTriangle->otherEdgeContaining(bVertex->getLabel(), zEdge->getLabel());    } else {        wEdge = bTriangle->edgeOppositeTo(aVertex->getLabel());    }    // identify the other important triangles    cTriangle = aTriangle->neighborFromEdge(yEdge->getLabel());    dTriangle = bTriangle->neighborFromEdge(vEdge->getLabel());    eTriangle = aTriangle->neighborFromEdge(xEdge->getLabel());    fTriangle = bTriangle->neighborFromEdge(wEdge->getLabel());}void MaximallyDegenerateUpdater::finishOneNeckIdentification() {    // since z is a one-neck, the a-b connection becomes a "rotating joint", e.g. the relative orientation of (c or e) and    // (d or f) is not important. Therefore, we can pick their corresponding edges at random, exluding already    // identified edges.    cVertex = aTriangle->vertexOppositeTo(zEdge->getLabel());    dVertex = bTriangle->vertexOppositeTo(zEdge->getLabel());    yEdge = aTriangle->getEdgeExcluding({zEdge});    xEdge = aTriangle->getEdgeExcluding({zEdge, yEdge});    vEdge = bTriangle->getEdgeExcluding({zEdge});    wEdge = bTriangle->getEdgeExcluding({zEdge, vEdge});    // identify the other important triangles    cTriangle = aTriangle->neighborFromEdge(yEdge->getLabel());    dTriangle = bTriangle->neighborFromEdge(vEdge->getLabel());    eTriangle = aTriangle->neighborFromEdge(xEdge->getLabel());    fTriangle = bTriangle->neighborFromEdge(wEdge->getLabel());}void MaximallyDegenerateUpdater::clearIdentification() {    aTriangle = nullptr;    bTriangle = nullptr;    cTriangle = nullptr;    dTriangle = nullptr;    eTriangle = nullptr;    fTriangle = nullptr;    vEdge = nullptr;    wEdge = nullptr;    xEdge = nullptr;    yEdge = nullptr;    zEdge = nullptr;    aVertex = nullptr;    bVertex = nullptr;    cVertex = nullptr;    dVertex = nullptr;}bool MaximallyDegenerateUpdater::isInnerTubeEdge() {    if (aTriangle->getLabel() == dTriangle->getLabel() && bTriangle->getLabel() == eTriangle->getLabel()) {        return true;    }    if (aTriangle->getLabel() == fTriangle->getLabel() && bTriangle->getLabel() == cTriangle->getLabel()) {        return true;    }    return false;}